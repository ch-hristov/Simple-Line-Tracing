# -*- coding: utf-8 -*-
"""line tracing

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15djc4xf8aSYNCwyQcwNfduwD9Xk-Rr99
"""

import numpy as np
from numba import jit
from tqdm import tqdm
import cv2 as cv

# Zheng Suen thinning
def thinning(src : np.array) -> np.array:
    dst = src.copy() / 255
    prev = np.zeros(src.shape[:2], np.uint8)
    diff = 0
    iter = 0
    while True:
        dst = _thinningIteration(dst, 0)
        dst = _thinningIteration(dst, 1)
        diff = np.absolute(dst - prev)
        prev = dst.copy()

        if np.sum(diff) == 0:
            break
        iter = iter + 1

    return dst * 255

def to_grayscale(img:np.array):
    img_gray = None
    if img.ndim == 2:
        img_gray = img
    elif img.ndim == 3:
        channels = img.shape[-1]
        if channels == 2:
            img_gray = img
        elif channels == 3:
            img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        elif channels == 4:
            img_gray = cv2.cvtColor(img, cv2.COLOR_BGRA2GRAY)
        else:
            raise Exception("Invalid number of chnanels : {0}".format(channels))
    return img_gray

def inverted_grayscale(img):
    uint_img = np.array(img)
    gray = to_grayscale(uint_img.astype(np.uint8))
    invert = cv2.bitwise_not(gray)
    ret,thr = cv2.threshold(invert, 20, 255, cv2.THRESH_OTSU)
    return thr

@jit
def _thinningIteration(im, iter_):
    M = np.zeros(im.shape, np.uint8)
    h, w = im.shape
    for i in range(1, h - 1):
        for j in range(1, w - 1):
            p2 = im[i - 1, j]
            p3 = im[i - 1, j + 1]
            p4 = im[i, j + 1]
            p5 = im[i + 1, j + 1]
            p6 = im[i + 1, j]
            p7 = im[i + 1, j - 1]
            p8 = im[i, j - 1]
            p9 = im[i - 1, j - 1]
            A = (p2 == 0 and p3 == 1) + (p3 == 0 and p4 == 1) + \
                (p4 == 0 and p5 == 1) + (p5 == 0 and p6 == 1) + \
                (p6 == 0 and p7 == 1) + (p7 == 0 and p8 == 1) + \
                (p8 == 0 and p9 == 1) + (p9 == 0 and p2 == 1)
            B = p2 + p3 + p4 + p5 + p6 + p7 + p8 + p9
            m1 = (p2 * p4 * p6) if (iter_ == 0) else (p2 * p4 * p8)
            m2 = (p4 * p6 * p8) if (iter_ == 0) else (p2 * p6 * p8)
            if A == 1 and B >= 2 and B <=6 and m1 == 0 and m2 == 0:
                M[i, j] = 1

    return  im.astype(np.uint8) & ~M

import urllib
def download_img():
  req = urllib.request.urlopen('https://blog.engisense.com/content/images/2024/03/110.jpg')
  arr = np.asarray(bytearray(req.read()), dtype=np.uint8)
  img = cv2.imdecode(arr, -1)
  return img

def preprocess():
  img = download_img()
  grayscale = inverted_grayscale(img)
  cv2.imwrite('grayscale.png', grayscale)
  thinned = thinning(grayscale)
  cv2.imwrite('thinned.png',thinned)
  colored = cv2.cvtColor(thinned, cv2.COLOR_GRAY2BGR)
  return thinned

data = preprocess()

import math
import random
from typing import List
from PIL import Image
from tqdm import tqdm
import cv2

def trace_continious_lines_vertical(im):
    deflated = im / 255
    h, w = im.shape
    lines = []

    for s in range(w):
        n = 0
        while n < h:
            start = n
            total = 0
            end = n
            while end < h and deflated[end][s] > 0.1:
                total = total + 1
                end = end + 1
            n = end + 1

            if total >= 2:
                    lines.append((
                        s,
                        start,
                        s,
                        end
                    ))

    return lines


def trace_continious_lines_horizontal(im):
    deflated = im / 255
    h, w = im.shape
    lines = []

    for s in range(h):
        n = 0
        while n < w:
            start = n
            total = 0
            end = n
            while end < w and deflated[s][end] > 0.1:
                total = total + 1
                end = end + 1
            n = end+1
            if total >= 2:
                    lines.append((
                        start,
                        s,
                        end,
                        s
                    ))

    return lines

def trace_xy(thinned_img: np.array):
  a = trace_continious_lines_horizontal(thinned_img)
  b = trace_continious_lines_vertical(thinned_img)
  return a + b

all_lines = trace_xy(data)
line_image  = np.copy(img)  # creating a blank to draw lines on
for line in tqdm(all_lines, "Line: "):
    x,y,x1,y1 = line[0], line[1], line[2], line[3]
    cv2.rectangle(line_image, (x, y), (x1, y1), (0, 0, 255), 1)
cv2.imwrite('traced.png', line_image)

